;; Predicates
(defglobal odd? [x] (!= (% x 2) 0))
(defglobal even? [x] (= (% x 2) 0))
(defglobal list? [x] (= (typeName x) "ARRAY"))
(defglobal string? [x] (= (typeName x) "STRING"))
(defglobal number? [x] (= (typeName x) "SCALAR"))
(defglobal bool? [x] (= (typeName x) "BOOL"))
(defglobal int? [x] (= (floor x) x))
(defglobal pos? [x] (> x 0))
(defglobal neg? [x] (< x 0))
(defglobal zero? [x] (= x 0))
(defglobal true? [x] (= x true))
(defglobal false? [x] (= x false))
(defglobal null? [x] (isNull x))

;; Functions
(defglobal inc [x] (+ x 1))
(defglobal dec [x] (- x 1))
(defglobal first [seq] (select seq 0))
(defglobal last [seq] (select seq (dec (count seq))))
(defglobal print [x] (hint (str x)))
(defglobal rand-int [n] (floor (random n)))
(defglobal take [n seq] (select seq 0 n))
(defglobal rest [seq]
  (setv ret [])
  (for [x 1 (count seq)]
    (pushBack ret (select seq x)))
  ret)

(defglobal dropn [seq n]
  (setv ret [])
  (for [i n (count seq)]
    (pushBack ret (select seq i)))
  ret)

(defglobal cut [seq ?start ?end]
  (cond
    (and (number? ?start) (number? ?end)) (select seq ?start (max (- ?end ?start) 0))
    (number? ?start) (dropn seq ?start)
    true seq))


;; Higher Order Functions
(defglobal reduce [f initial seq]
  (setv accum initial)
  (for [curr seq]
    (reset! accum (f accum curr)))
  accum)

(defglobal map [f seq]
  (setv ret [])
  (for [x seq]
    (pushBack ret (f x)))
  ret)

(defglobal filter [pred seq]
  (setv ret [])
  (for [x seq]
    (if (pred x) (pushBack ret x)))
  ret)
